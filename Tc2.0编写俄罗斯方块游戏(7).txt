                         
						 Tc2.0编写俄罗斯方块游戏(7)

作者：陈畅
联系地址：上海财经大学图书馆
电子邮件：shchenchang@gmail.com
个人主页：http://shchenchang.spaces.live.com
QQ:7019717（欢迎编程爱好者加我为好友）


关于俄罗斯方块程序的一些问题：
******************************************************
Tc2.0中怎么样设置图形显示？
Tc2.0中常用图形函数的用法？
怎样获取I盘输入？
怎样控制方块的移动？
怎样控制时间间隔(用于游戏中控制形状的下落)？
游戏中的各种形状及整个游戏空间怎么用数据表示？
游戏中怎么判断左右及向下移动的可能性？
游戏中怎么判断某一形状旋转的可能性？
按向下方向键时加速某一形状下落速度的处理？
怎么判断某一形状已经到底？
怎么判断某一已经被填满？
怎么消去已经被填满的一行？
怎么消去某一形状落到底后能够消去的所有的行？(如长条最多可以消去四行)
怎样修改游戏板的状态？
怎样统计分数？
怎样处理升级后的加速问题？
怎样判断游戏结束？
关于计分板设计的问题。
关于“下一个”形状取法的问题。
剩下的问题。

******************************************************
新的问题：
我想有一个最高记录的显示，应该怎么做呀？
我想实现一个进度存储功能，应该怎么做呀？




怎么判断某一行已经被填满？

判断第y行被填满的的函数是RowFull()。第y行只要有一个位置为空，则第y行一定没有被填
满。如果第y行所有的位置都不为空，那么第y行已被填满。RowFull()就是按这个思路写的
。

enum bool RowFull(int y)
{
	int i;
	for (i=1;i<=10;i++)
		if (!board[i][y]) return False;
	return True;
}



怎么消去已经被填满的一行？

假设第y行已经被填满，现在要消去这一行。和大家玩这个游戏时所看到的一样，就是使所
有上面的行(纵坐标小于y大于等于1的所有的行)都下移一层。从第y层开始，直到第2层为止
，依次比较相邻两层中的表示位置是否被填充的标志。如果上下两层的填充标志相等(都被
填充或都未被填充)，则继续比较下一个同列的位置。如果上下两层的填充标志不相等，则
使下层的填充标志等于上层的填充标志，同时修改游戏板的显示。如果填充标志为1，则在
相应的位置用前景色画一个方块，表示该处已被填充；否则填充标志为0，则在相应的位置
用背景色画一个方块，表示该处还空着。这样就实现了消去一行。

DeleteRow()就是按这个思路写出来的。消去第y行。

void DeleteRow(int y)
{
	int i,j;
	for (j=y;j>=2;j--) /* 从y行开始，依次向上比较 */
		for (i=1;i<=10;i++) /* 依次比较各列 */
		{
			/* 上下两层填充标志相等，直接继续下一列的比较 */
			if (board[i][j]==board[i][j-1]) continue;


			/* 上下两层填充标志不相等 */
			
			/* 上层填充标志为1 */
			if (board[i][j-1]==1)
			{
				/* 修改下层填充标志也为1 */
				board[i][j]=1;

				/* 准备用前景色修改下层该处的方块 */
				setfillstyle(SOLID_FILL,FORECOLOR);
			}
			else /* 上层填充标志为0 */
			{
				/* 修改下层填充标志也为0 */
				board[i][j]=0;
				
				/* 准备用背景色修改下层该处的方块 */
				setfillstyle(SOLID_FILL,BGCOLOR);
			}

			/* 用选择的前景色或背景色重绘下层该处的方块 */
			DrawBlock(i,j);
		}
}




怎么消去某一形状落到底后能够消去的所有的行？(如长条最多可以消去四行)

假定某一形状在坐标(x,y)处到底，这时从第y行开始检查，看能够消去多少层。从第y行开
始，最多消去4层。

假设一根长条竖着插下来，坐标为(x,y)，刚好能消去四层。实际上消去四层的过程这样的
：检查第y层，发现第y层满，消去第y层。继续检查第y层，发现y层还满，则继续消去y层。
这个过程一共重复四次。

就是说，从第y层开始，只要第y层能消，就一直消第y层，直到第y层不能消为止。然后再检
查第y-1层。如果第y-1层能消，就一直消第y-1层，直到第y-1层不能消为止。然后再检查第
y-2层……

这一过程是通过DeleteRows()函数来实现的，函数最后返回消去的总行数。

int DeleteRows(int y)
{
	int i,rows=0;
	for (i=0;i<=3;i++) /* 最多消去4行，所以只须循环4次 */
	{
		while (RowFull(y)) /* 只要第y行能消，就一直消第y行 */
		{
			DeleteRow(y);
			rows++;
			i++;
		}
		y--; /* 继续检测上一行 */
		if (y<1) break; /* 
y<1时，已经超出游戏板的范围了，不需要再羊判断了 */
	}
	return rows; /* 返回消去的总行数 */
};

DeleteRows()这个函数可能看起来有点奇怪，但实事上就是这样的。^_^ 
如果你还不太明白，请再仔细琢磨琢磨这段源代码。




