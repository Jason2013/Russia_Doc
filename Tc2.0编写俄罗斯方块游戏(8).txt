                         
						 Tc2.0编写俄罗斯方块游戏(8)

作者：陈畅
联系地址：上海财经大学图书馆
电子邮件：shchenchang@gmail.com
个人主页：http://shchenchang.spaces.live.com
QQ:7019717（欢迎编程爱好者加我为好友）


关于俄罗斯方块程序的一些问题：
******************************************************
Tc2.0中怎么样设置图形显示？
Tc2.0中常用图形函数的用法？
怎样获取I盘输入？
怎样控制方块的移动？
怎样控制时间间隔(用于游戏中控制形状的下落)？
游戏中的各种形状及整个游戏空间怎么用数据表示？
游戏中怎么判断左右及向下移动的可能性？
游戏中怎么判断某一形状旋转的可能性？
按向下方向键时加速某一形状下落速度的处理？
怎么判断某一形状已经到底？
怎么判断某一已经被填满？
怎么消去已经被填满的一行？
怎么消去某一形状落到底后能够消去的所有的行？(如长条最多可以消去四行)
怎样修改游戏板的状态？
怎样统计分数？
怎样处理升级后的加速问题？
怎样判断游戏结束？
关于计分板设计的问题。
关于“下一个”形状取法的问题。
剩下的问题。

******************************************************
新的问题：
我想有一个最高记录的显示，应该怎么做呀？
我想实现一个进度存储功能，应该怎么做呀？




怎样修改游戏板的状态？

当当前形状落到底后，就要修改游戏板的状态了。游戏板的状态是游戏中最重要的信息了，
各种各样移动，旋转的判断通是通过它来计算的。

修改游戏板状态的代码是这一小段，




				/* 
用前景色绘制当前形状，标志当前形状已经不能再动了 
*/
				DrawShape(CurShape,sx,sy,FORECOLOR);

				/* 
修改游戏板状态，将当前形状盖住的位置全部标志为1 
*/
				for (i=0;i<=7;i++,i++) /* 依次修改游戏板状态 */
				{
					
					/* 超出游戏板范围时，跳过 */
					if (sy+shapes[CurShape].xy[i+1]<1) 
continue;
					
					/* 标志被盖的位置为1 */
					
board[sx+shapes[CurShape].xy[i]][sy+shap
es[CurShape].xy[i+1]]=1;
				}






怎样统计分数？

接下来的几个问题都很简单了。

统计分数是根据消的行数来计算的。
消1行，得1分；(平均每行1分)
消2行，得3分；(平均每行1.5分)
消3行，得6分；(平均每行2分)
消4行，得10分；(平均每行2.5分)
这种计分方法鼓励玩家做“大”。：)

int Bonus(int num)
{
	switch(num)
	{
	case 1:
		return 1;
	case 2:
		return 3;
	case 3:
		return 6;
	case 4:
		return 10;
	}
	return 0;
}

其实这个函数可以写成这样：

int Bonus(int num)
{
	return ((num-1)+2)*num/2;
}

效果和上面的一模一样，但是程序的可读行还是上面的好，一目了然。所以在程序中采用了
上面一种。(其实从程序的执行效率上来考虑，下面的这个也不一定比上面的高。)




怎样处理升级后的加速问题？

下一级的升级分数由变量lnNextLevelScore来控制。当分数超过升分数的时候，就修改过升
分数为再下一级的升级分数，同时加快游戏中开脱形状下落的速度。

下面这段代码详细解释了上面说的两个问题。


						/* 得到消去的总行数 */
						increase=DeleteRows(sy);
						
						/* 
如果消去的行数不为0，则要统计分
数 */
						if(increase) /* add score */
						{
							
							/* 
根据行数计算得分，并加在
总分中 */
							score+=Bonus(increase);

							/* 显示新的总分 */
							
NumBoard(SIZE*22,SIZE*19
+3,7,score);
							
							/* 如果分数超过升分数 */
							if 
(score>lnNextLevelScore) 
/* add speed */
							{
								
								/* 
修改升级分数为下
一级升级分数 */
								
lnNextLevelScore
+=SCOREINTERVAL;

								/* 提高游戏速度 
*/
								speed++;

								/* 
显示新的游戏速度 
*/
								
NumBoard(SIZE*22
,SIZE*15+3,7,spe
ed);
							}
						}





怎样判断游戏结束？

如果游戏板最高层的任何位置被填充，那么游戏就结束了。这是通过CheckGameOver()函数
来实现的。
代码很简单，不用多说了。

enum bool CheckGameOver()
{
	int i;
	for (i=1;i<=10;i++)
		if (board[i][1]) return True;
	return False;
}





关于消息板设计的问题。

先画个矩形框，然后在里边写上数字或字符串就行了。数字右对齐，字符串居中对齐。你要
是愿意多花点功夫，还可以做得更好看一些。这是由NumBoard()和MsgBoard()函数来实现的
。没什么特别的，不用多说了。




关于“下一个”形状取法的问题。

下一个形状的序号由全局全量next记录。next初值为-1，表示还没有取下一个形状。next由
GetNextShape()函数取得。这个函数很简单，但是不怎么好理解。为什么要这么写呢？听我
详细解释。


int GetNextShape()
{
	int i;
	i=rand()%28;
	if (i<12) return i;
	if (i<24) return (i-12)/2+12;
	return 18;
}


对程序员来说，形状一共有19种；而对玩家来说，形状只有7种。因此，我们应当按照玩家
的观点，确保7种形状出现的概率相等。因此要想把办法把玩家眼里的这7种形状转换成我们
实际的19种形状，同时要保证玩家眼里的7种形状出现的概率相等。

i=rand()%28，那么i是从0-27的一个整数。每4个数表示一种形状，刚好是7种形状。

前3种形状(在玩家看来)，各有4种变化，随机产生的序号就对应我们想要的序号(19种形状
之一)。
i等于0,1,2,3时，直接返回形状的序号。
i等于4,5,6,7时，直接返回形状的序号。
i等于8,9,10,11时，直接返回形状的序号。

接下来3种形状(在玩家看来)，各有2种变化，随机产生的序号需要进行一下转换。
转换规则如下：
i等于12,13,14,15时；
	当i等于12,13时，返回12；
	当i等于14,15时，返回13。
i等于16,17,18,19时；
	当i等于16,17时，返回14；
	当i等于18,19时，返回15。
i等于20,21,22,23时；
	当i等于20,21时，返回16；
	当i等于22,23时，返回17。

最后1种形状(在玩家看来)，只有1种变化。
i等于24,25,26,27时，直接返回18。

这样就将玩家眼里的7种形状转换成了实际的19种形状之一，而且7种形状出现的概率相等，
都是1/7(就是4/28)。从这里也可以看出，19种形状的顺序安排还是有点学问的呀。：)




