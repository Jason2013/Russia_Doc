                         
						 Tc2.0编写俄罗斯方块游戏(5)

作者：陈畅
联系地址：上海财经大学图书馆
电子邮件：shchenchang@gmail.com
个人主页：http://shchenchang.spaces.live.com
QQ:7019717（欢迎编程爱好者加我为好友）


关于俄罗斯方块程序的一些问题：
******************************************************
Tc2.0中怎么样设置图形显示？
Tc2.0中常用图形函数的用法？
怎样获取I盘输入？
怎样控制方块的移动？
怎样控制时间间隔(用于游戏中控制形状的下落)？
游戏中的各种形状及整个游戏空间怎么用数据表示？
游戏中怎么判断左右及向下移动的可能性？
游戏中怎么判断某一形状旋转的可能性？
按向下方向键时加速某一形状下落速度的处理？
怎么判断某一形状已经到底？
怎么判断某一已经被填满？
怎么消去已经被填满的一行？
怎么消去某一形状落到底后能够消去的所有的行？(如长条最多可以消去四行)
怎样修改游戏板的状态？
怎样统计分数？
怎样处理升级后的加速问题？
怎样判断游戏结束？
关于计分板设计的问题。
关于“下一个”形状取法的问题。
剩下的问题。

******************************************************
新的问题：
我想有一个最高记录的显示，应该怎么做呀？
我想实现一个进度存储功能，应该怎么做呀？




游戏中怎么判断左右及向下移动的可能性？（续）

有了 enum bool Confilict(int ShapeIndex,int x,int y) 
这个函数后，判断形状左右及向下移动的可能性就方便了。

来看这个函数：
enum bool Moveable(int  ShapeIndex,int x,int y,enum direct dir)
{
	switch(dir)
	{
	case Left:
		if (Confilict(ShapeIndex,x-1,y))
			return False;
		return True;
	case Right:
		if (Confilict(ShapeIndex,x+1,y))
			return False;
		return True;
	case Down:
		if (Confilict(ShapeIndex,x,y+1))
			return False;
		return True;
	}
	return False;
}

这个函数很简单，判断索引号为ShapeIndex的形状在(x,y)向dir方向移动的可能性。很简单
，假设索引号为ShapeIndex的形状已经向dir方向移了一格，判断此时是否发生冲突。没有
发生冲突，则可以向dir方向移动；否则，不可以向dir方向移动。




游戏中怎么判断某一形状旋转的可能性？

旋转判断的可能性与左右及向下移动的可能性的判断差不多，只是有些小差别。

来看看这个函数。

enum bool Rollable(int ShapeIndex,int x,int y,int *offset)
{
	int NextShape;
	static int arrOffset[5]={0,-1,1,-2,2};
	int i;
	NextShape=shapes[ShapeIndex].next;

	for (i=0;i<=4;i++)
		if (!Confilict(NextShape,x+arrOffset[i],y))
		{
			*offset=arrOffset[i];
			return True;
		}
	return False;
}

比那个Moveable()多了个offset型的指针参数。这个参数有什么用呢？

先取得索引号为ShapeIndex的形状逆时针旋转后的形状的索引号，赋给NextShape。来检查N
extShape形状在(x,y)处是否与游戏板当前状态冲突。如果不冲突，那么索引号为ShapeInde
x的形状在(x,y)可以旋转，同时，x偏移量*offset为0。否则要继续判断。现在来检查NextS
hape形状在(x-1,y)处是否与游戏板当前状态冲突。如果不冲突，那么索引号为ShapeIndex
的形状在(x,y)可以旋转，同时，选转后x偏移量*offset为-1。如果冲突，则用同样的办法
，继续假设x偏移量为1、-2、2时是否冲突，那么索引号为ShapeIndex的形状在(x,y)可以旋
转，同时，选转后x偏移量*offset为1、-2、2。如果都冲突，那么此时ShapeIndex形状在(x
,y)处不能逆时针旋转。

来看一个例子：

   1 2 3 4 5 6 7 8 910
 1□□□□□□□□□□
 2■■■□□□□□□□  “T”形状现在的坐标是(2,3)
 3□■□□□□□□□□
 4□□□□□□□□□□
 5□□□□□□□□□□
 6□□□□□□□□□□
 7■□□□□□□□□□  “L”形状现在的坐标是(1,9)
 8■□□□□□□□□□
 9■■□□□□□□□□
10□□□□□□□□□□
11□□□□□□□□□□
12□□□□□□□□□□
13□□□□□□□□□■  长条形状现在的坐标是(10,16)
14□□□□□□□□□■
15□□□□□□□□□■
16□□□□□□□□□■
17□□□□□□□□□□
18□□□□□□□□□□
19□□□□□□□□□□
20□□□□□□□□□□

   1 2 3 4 5 6 7 8 910
 1□■□□□□□□□□
 2□■■□□□□□□□  “T”形状旋转后的坐标是还是(2,3)，x偏移量为0
 3□■□□□□□□□□
 4□□□□□□□□□□
 5□□□□□□□□□□
 6□□□□□□□□□□
 7□□□□□□□□□□
 8□□■□□□□□□□  “L”形状旋转后的坐标变成(2,9)，x偏移量为1
 9■■■□□□□□□□
10□□□□□□□□□□
11□□□□□□□□□□
12□□□□□□□□□□
13□□□□□□□□□□
14□□□□□□□□□□
15□□□□□□□□□□
16□□□□□□■■■■  长条形状旋转后的坐标变成(8,16)，x偏移量为-2
17□□□□□□□□□□
18□□□□□□□□□□
19□□□□□□□□□□
20□□□□□□□□□□

现在知道offset这个指针变量的用处理了吧，是用来记录形状旋转后的x位移量的。


实现移动和旋转的两个函数Move()和Roll()就相当简单了。就是将原来位置上的形状用背景
色涂掉，然后修改当前形状的(x,y)坐标，再在新的位置上用当前形状的颜色重新绘制当前
形状。具体代码请参见程序。